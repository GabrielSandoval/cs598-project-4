---
title: "Project 4 - System I"
---

## Submission Info

Names:

- Gabriel Angelo Sandoval (NETID: grs4)
- Purohit Praveen (NETID: purohit4)

Contributions:

- Both team members worked on different parts of the code and concluded it together.

## Demo and Code

* `Demo` [[Shinyapp_link](https://grs4.shinyapps.io/content_based_filtering)]
* `Code` [[Github_link](https://github.com/GabrielSandoval/cs598-project-4/tree/master/content_based_filtering)]

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=TRUE)
```

```{r include=FALSE}
library(dplyr)
library(ggplot2)
library(recommenderlab)
library(DT)
library(data.table)
library(reshape2)
library(stringr)
```

## Download Data

Download the MovieLens 1M Dataset. There are four files: 

 * `README` [[Github_link](https://liangfgithub.github.io/MovieData/README?raw=true)]
 * `movies.dat` [[Github_link](https://liangfgithub.github.io/MovieData/movies.dat?raw=true)]
 * `ratings.dat` [[Github_link](https://liangfgithub.github.io/MovieData/ratings.dat?raw=true)]
 * `users.dat` [[Github_link](https://liangfgithub.github.io/MovieData/users.dat?raw=true)]
 
```{r include=FALSE}
 myurl = "https://liangfgithub.github.io/MovieData/"
```

## Read/Preprocess the Data

### Ratings data

Ratings data consists of 4 columns: UserID, MovieID, Rating, Timestamp

```{r message=FALSE, warning=FALSE, echo=FALSE}
# use colClasses = 'NULL' to skip columns
ratings = read.csv(paste0(myurl, 'ratings.dat?raw=true'), 
                   sep = ':',
                   colClasses = c('integer', 'NULL'), 
                   header = FALSE)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
```

Below is how the Ratings data look like:
```{r, result='asis', echo=FALSE}
datatable(head(ratings, 6), 
          class = "nowrap hover row-border", 
          options = list(dom = 't',
                         scrollX = FALSE, 
                         autoWidth = TRUE))
```
This data can be interpreted as:

For the first row, User 1 rated Movie 1193 with 5 at timestamp 978300760.

### Movies data

```{r include=FALSE}
movies = readLines(paste0(myurl, 'movies.dat?raw=true'))
movies = strsplit(movies, split = "::", fixed = TRUE, useBytes = TRUE)
movies = matrix(unlist(movies), ncol = 3, byrow = TRUE)
movies = data.frame(movies, stringsAsFactors = FALSE)
colnames(movies) = c('MovieID', 'Title', 'Genres')
movies$MovieID = as.integer(movies$MovieID)
```

Some movie titles are accented. On these cases, we convert the encoding to UTF-8.

Below is an example:
```{r message=FALSE, warning=FALSE, echo=FALSE}
# convert accented characters
movies$Title[73]
```

```{r message=FALSE, warning=FALSE, echo=FALSE}
movies$Title = iconv(movies$Title, "latin1", "UTF-8")
movies$Title[73]
```

After that, we extracted the year of release of the movie from the title.
```{r include=FALSE}
# extract year
movies$Year = as.numeric(unlist(
  lapply(movies$Title, function(x) substr(x, nchar(x)-4, nchar(x)-1))))
```

Below is how the Movies data look like:
```{r, result='asis', echo=FALSE}
datatable(head(movies, 6), 
          class = "nowrap hover row-border", 
          options = list(dom = 't',
                         scrollX = FALSE, 
                         autoWidth = TRUE))
```

This data can be interpreted as:

For the first row, Movie 1 which was released on 1995 has the Title "Toy Story (1995)" tagged with Genres Animation, Children's and Comedy.

## Making Recommendations (Content-Based filtering)

There are three simple ways on how we can give recommendations to a user given we know the genre he/she is interested in.

### Method 1:

For a user-given genre, the simplest way we can make recommendations is by getting all the movies tagged with that genre and calculating the average rating per movie. The movie with the highest average rating is placed higher in the list while the movie with the lesser average rating is placed lower in the list. Below is the popularity metric:

$Popularity_m = \frac{\sum_{n=1}^{N}[R_n]}{N}$

Where:

$Popularity_m$ is the Popularity metric for movie $m$

$N$ is the number of users

$n$ is the user

$R_n$ is Movie rating of user n

#### Sample Result:

```{r, result='asis', message=FALSE, warning=FALSE, echo=FALSE}
small_image_url = "https://liangfgithub.github.io/MovieImages/"
ratings %>% 
  group_by(MovieID) %>% 
  summarize(ratings_per_movie = n(), 
            ave_ratings = round(mean(Rating), dig=3)) %>%
  inner_join(movies, by = 'MovieID') %>%
  filter(str_detect(Genres, "Comedy")) %>%
  top_n(10, ave_ratings) %>%
  mutate(Image = paste0('<img src="', 
                        small_image_url, 
                        MovieID, 
                        '.jpg?raw=true"></img>')) %>%
  select('Image', 'Title', 'ave_ratings') %>%
  arrange(desc(ave_ratings)) %>%
  datatable(class = "nowrap hover row-border", 
            escape = FALSE, 
            options = list(dom = 't',
                          scrollX = TRUE, autoWidth = TRUE))
```
This however introduces a bias toward movies with few ratings. For the example above, the average rating of the movie "Follow the Bitch" is 5 but if we look at the dataset, we observe that the movie was only rated by one person.

Similar to the case of the second most-'popular' movie on this recommendation list, "Smashing Time" received a perfect average rating but only 2 users rated that movie.

In order to solve this issue, we can filter out movies that have less than $N$ (threshold) number of ratings. It is also important to consider that this $N$ threshold does not apply for all genres since not all genres have the same number of user ratings.

With that in context, we explore the data further to know the distribution of ratings per genre pick a threshold based on that.

### Method 2:

#### Distribution of Ratings per Genre

First create a binary indicator for the 18 genres a movie.  
```{r, result='asis', message=FALSE, warning=FALSE, echo=FALSE}
genres = as.data.frame(movies$Genres, stringsAsFactors=FALSE)
tmp = as.data.frame(tstrsplit(genres[,1], '[|]',
                              type.convert=TRUE),
                    stringsAsFactors=FALSE)
genre_list = c("Action", "Adventure", "Animation", 
               "Children's", "Comedy", "Crime",
               "Documentary", "Drama", "Fantasy",
               "Film-Noir", "Horror", "Musical", 
               "Mystery", "Romance", "Sci-Fi", 
               "Thriller", "War", "Western")
m = length(genre_list)
genre_matrix = matrix(0, nrow(movies), length(genre_list))
for(i in 1:nrow(tmp)){
  genre_matrix[i,genre_list %in% tmp[i,]]=1
}
colnames(genre_matrix) = genre_list
remove("tmp", "genres")
```

For example, the genres for the movie "Toy Story (1995)" can be expressed as:

```{r, result='asis', message=FALSE, warning=FALSE, echo=FALSE}
genre_matrix[1, ]
```

We do this for all movies. After that, we create a histogram showing the number of ratings for the 18 genres.

```{r, result='asis', message=FALSE, warning=FALSE, echo=FALSE}
tmp = ratings %>% 
  left_join(data.frame(MovieID = movies$MovieID, genre_matrix), 
            by = "MovieID") %>%
  select(-c("UserID", "MovieID", "Rating", "Timestamp"))
data.frame(Genres = genre_list, 
                 Popularity = as.vector(colSums(tmp))) %>% 
  ggplot(aes(reorder(Genres, Popularity), Popularity, fill = Popularity)) + 
  geom_bar(stat = "identity") + 
  geom_text(aes(label = round(Popularity, dig=3)), 
            position = position_stack(vjust = 0.5), 
            color="white", size=3) + 
  coord_flip() + 
  labs(y = 'Number of Ratings', x = 'Genre')
```
### Threshold per Genre

Now that we know the distribution, we can pick a number relative the genre's number of rating. By doing empirical tests, we found that the following threshold per genre give good results:

$N = 1000$ for Comedy, Drama, Action, Thriller, Sci-Fi, Romance, Adventure

$N = 50$ for Crime, Horror, Children's, War

$N = 200$ for Animation, Musical, Mystery, Fantasy, Western, Film-Noir, Documentary

Following threshold above for Comedy ($N=1000$) we get the following recommendations.

#### Sample Result:
```{r, result='asis', message=FALSE, warning=FALSE, echo=FALSE}
small_image_url = "https://liangfgithub.github.io/MovieImages/"
ratings %>% 
  group_by(MovieID) %>% 
  summarize(ratings_per_movie = n(), 
            ave_ratings = round(mean(Rating), dig=3)) %>%
  inner_join(movies, by = 'MovieID') %>%
  filter(str_detect(Genres, "Comedy")) %>%
  filter(ratings_per_movie > 1000) %>%
  top_n(10, ave_ratings) %>%
  mutate(Image = paste0('<img src="', 
                        small_image_url, 
                        MovieID, 
                        '.jpg?raw=true"></img>')) %>%
  select('Image', 'Title', 'ave_ratings') %>%
  arrange(desc(ave_ratings)) %>%
  datatable(class = "nowrap hover row-border", 
            escape = FALSE, 
            options = list(dom = 't',
                          scrollX = TRUE, autoWidth = TRUE))
```

### Method 3:

Since some users prefer more recent movies as recommendation, another datapoint we can consider is the release date of the movie. In addition to the average rating of the users per movie, we can add a recency function to boost our 'popular' metric. Below shows the simplest linear function we can use for boosting:

```{r, result='asis', message=FALSE, warning=FALSE, echo=FALSE}
recency_function = function(year) {
  minYear = min(movies$Year)
  maxYear = max(movies$Year)

  return(1 + (year - minYear) / (maxYear - minYear))
}

plot(recency_function(1919:2000), type='l', col='red', ylab='Boost', xlab='Movie Release (Year)', xaxt="n")
title("Receny Boost function")
axis(1, at = seq(0, 90, by = 10), labels=c(1919, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000,2010))
```
$f(year) = 1 + \frac{year - 1919}{2000 - 1919}$

Where: 

$year$ is the year the movie was released

The above graph shows the more recent the movie is, the greater the boost we'll introduce to the 'popular' metric.

Our new 'popular' metric will now be:

$Popularity_m = \frac{\sum_{n=1}^{N}[R_n]}{N}f(year_m)$

Where:

$N$ is the number of users

$n$ is the user

$R_n$ is Movie rating of user $n$

$year_m$ is the year movie $m$ was released

$f(year_m)$ is the recency boost function

#### Sample Result:
```{r, result='asis', message=FALSE, warning=FALSE, echo=FALSE}
small_image_url = "https://liangfgithub.github.io/MovieImages/"
ratings %>% 
  group_by(MovieID) %>% 
  summarize(ratings_per_movie = n(), 
            Score = round(mean(Rating), dig=3)) %>%
  inner_join(movies, by = 'MovieID') %>%
  filter(str_detect(Genres, "Comedy")) %>%
  filter(ratings_per_movie > 1000) %>%
  top_n(10, Score) %>%
  mutate(Image = paste0('<img src="', 
                        small_image_url, 
                        MovieID, 
                        '.jpg?raw=true"></img>')) %>%
  mutate(Score = round(Score * recency_function(Year), dig=3)) %>%
  select('Image', 'Title', 'Score') %>%
  arrange(desc(Score)) %>%
  datatable(class = "nowrap hover row-border", 
            escape = FALSE, 
            options = list(dom = 't',
                          scrollX = TRUE, autoWidth = TRUE))

```

Compared to the results in Method 2, we can observe that the more recent movies are higher up the list.

Depending on the data, we can change the boost function.
